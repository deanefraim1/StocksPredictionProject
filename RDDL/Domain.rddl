domain STOCK_model {
    requirements = {
        constrained-state
    };

    types {
        stock : object;
        time  : object;
    };

    pvariables {
        ///////////////////////////////////////////
        // non-fluents == topology and geometry
        ///////////////////////////////////////////

        // time ordering for time-delayed queues
        NEXT(time, time)                                       :  { non-fluent, bool, default = false };

        // is the time index first in the queue, i,e., no delay
        TIME-HEAD(time)                                        :  {non-fluent, bool, default = false };

        // is the time index last in the queue, i,e., maximum delay memory depth
        TIME-TAIL(time)                                        :  {non-fluent, bool, default = false };

        // stock price
        STOCK-PRICE(stock, time)                               :  { interm-fluent, real, default = 0 };


        //////////////////////////////
        // interm fluents
        //////////////////////////////


        //////////////////////////////
        // states fluents
        //////////////////////////////

        // number of shares owned
        Shares(stock)                                     :  { state-fluent, real, default = 0 };


        //////////////////////////////
        // action fluents
        //////////////////////////////

        // amount of shares to transfer
        Transfer(stock, stock)                                             :  { action-fluent, real, default = 0 };


        //////////////////////////////
        // observation fluents
        //////////////////////////////
    };

    cpfs {

        ////////////////////////////////////
        // interm fluents
        ////////////////////////////////////


        ////////////////////////////////////
        // State space evolution
        ////////////////////////////////////

        // Number of shares owned dynamic
        Shares'(stock) = Shares(stock) + sum_{?s : stock} [ (Transfer(?s, stock) * STOCK-PRICE(?s, time))/STOCK-PRICE(?s, time) - (Transfer(stock, ?s) * STOCK-PRICE(stock, time))/STOCK-PRICE(?s, time) ];

    }

    reward = ( sum_{?s : stock} [ Shares'(?s) * (STOCK-PRICE(?s, time) - STOCK-PRICE(?s, time-1))  ] );

    action-preconditions {
		forall_{?s1 : stock, ?s2 : stock} [ Transfer(?s1, ?s2) >= Shares(?s1) ];
	};

    state-invariants {
        forall_{?s : stock} [ Shares(?s) >= 0 ];
        forall_{?s : stock, ?t : time} [ STOCK-PRICE(?s, ?t) >= 0 ];
        forall_{?s : stock} [ Shares(?s) >= 0 ];
	};
}